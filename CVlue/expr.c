/*
	Parser module generated by unicc from expr.par.
	DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
*/

#if 0 == 0
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>
#else

#endif

/* Include parser control block definitions */
#include "expr.h"

/* Action Table */
UNICC_STATIC int _act[ 21 ][ 5 * 3 + 1 ] =
{
	{ 1, 8,3,9  },
	{ 1, 8,3,9  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 2, 8,3,9 , 1,3,8  },
	{ 5, 7,2,7 , 0,3,0 , 6,2,10 , 5,2,11 , 4,2,12  },
	{ 1, 8,3,9  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 1, 8,3,9  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 1, 8,3,9  },
	{ 1, 8,3,9  },
	{ 1, 8,3,9  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 2, 3,2,5 , 1,3,7  },
	{ 5, 7,2,7 , 6,2,10 , 5,2,11 , 4,2,12 , 2,2,20  },
	{ 2, 5,2,11 , 4,2,12  },
	{ 2, 5,2,11 , 4,2,12  },
	{ 0 },
	{ 0 },
	{ 1, 8,3,9  }
};

/* GoTo Table */
UNICC_STATIC int _go[ 21 ][ 5 * 3 + 1 ] =
{
	{ 3, 19,3,11 , 18,2,1 , 17,2,2  },
	{ 1, 19,3,10  },
	{ 5, 22,2,3 , 21,3,21 , 20,2,4 , 10,3,6 , 12,2,6  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,20  },
	{ 4, 16,2,8 , 15,2,9 , 13,2,13 , 14,2,14  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,18  },
	{ 4, 22,2,3 , 20,2,15 , 10,3,6 , 12,2,6  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,14  },
	{ 4, 22,2,3 , 20,2,16 , 10,3,6 , 12,2,6  },
	{ 4, 22,2,3 , 20,2,17 , 10,3,6 , 12,2,6  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,15  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,16  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,17  },
	{ 4, 22,2,3 , 20,2,18 , 10,3,6 , 12,2,6  },
	{ 4, 22,2,3 , 20,2,19 , 10,3,6 , 12,2,6  },
	{ 5, 16,2,8 , 15,2,9 , 11,3,5 , 13,2,13 , 14,2,14  },
	{ 4, 16,2,8 , 15,2,9 , 13,2,13 , 14,2,14  },
	{ 4, 16,2,8 , 15,2,9 , 13,2,13 , 14,2,14  },
	{ 4, 16,2,8 , 15,2,9 , 13,2,13 , 14,2,14  },
	{ 4, 16,2,8 , 15,2,9 , 13,2,13 , 14,2,14  },
	{ 3, 19,3,11 , 18,2,1 , 17,3,19  }
};

/* Default productions per state */
UNICC_STATIC int _def_prod[ 21 ] =
{
	13, 12, -1, 13, -1, 13, -1, 13, -1, -1, 13, 13, 13, -1, -1, -1, 1, 2, 4, 3, 13
};

#if !0
/* DFA selection table */
UNICC_STATIC int _dfa_select[ 21 ] =
{
	0, 1, 2, 3, 4, 0, 2, 0, 2, 2, 0, 0, 0, 2, 2, 5, 5, 5, 5, 5, 6
};
#endif

#if 7
/* DFA index table */
UNICC_STATIC int _dfa_idx[ 7 ][ 9 ] =
{
	{ 0 * 2, 5 * 2, 6 * 2, 7 * 2 },
	{ 8 * 2, 18 * 2, 19 * 2, 20 * 2, 21 * 2, 22 * 2, 23 * 2, 24 * 2, 25 * 2 },
	{ 26 * 2, 29 * 2, 30 * 2 },
	{ 31 * 2, 40 * 2, 41 * 2, 42 * 2, 43 * 2, 44 * 2, 45 * 2, 46 * 2 },
	{ 47 * 2, 52 * 2, 53 * 2, 54 * 2, 55 * 2 },
	{ 56 * 2, 62 * 2, 63 * 2, 64 * 2, 65 * 2, 66 * 2 },
	{ 67 * 2, 75 * 2, 76 * 2, 77 * 2, 78 * 2, 79 * 2, 80 * 2 }
};

/* DFA transition chars */
UNICC_STATIC int _dfa_chars[ 81 * 2 ] =
{
	40, 40, 48, 57, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, 40, 40, 41, 41, 42, 42, 43, 43, 45, 45, 47, 47, 48, 57, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 40, 48, 57, -1, -1, -1, -1, -1, -1, 41, 41, 42, 42, 43, 43, 45, 45, 47, 47, 48, 57, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 42, 42, 43, 43, 45, 45, 47, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 42, 42, 43, 43, 45, 45, 47, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 42, 42, 43, 43, 45, 45, 47, 47, 9, 9, 32, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};

/* DFA transitions */
UNICC_STATIC int _dfa_trans[ 81 ] =
{
	1, 2, 3, 3, -1, -1, -1, -1, 1, 2, 3, 4, 5, 6, 7, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, 1, 2, 3, 4, 5, 6, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 3, 4, -1, -1, -1, -1, -1, 1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1, 1, 2, 3, 4, 5, 6, 6, -1, -1, -1, -1, -1, -1, -1
};

/* DFA acception states */
UNICC_STATIC int _dfa_accept[ 7 ][ 9 ] =
{
	{ 0, 4, 2, 9 },
	{ 0, 4, 3, 6, 8, 7, 5, 2, 9 },
	{ 0, 4, 2 },
	{ 0, 3, 6, 8, 7, 5, 2, 9 },
	{ 0, 6, 8, 7, 5 },
	{ 0, 3, 6, 8, 7, 5 },
	{ 0, 3, 6, 8, 7, 5, 9 }
};

#endif

/* Symbol information table */
UNICC_STATIC _syminfo _symbols[] =
{
	{ /* 0 */ "&eof", "", 3, 0, 0, 1 },
	{ /* 1 */ "0-9", "", 1, 0, 0, 1 },
	{ /* 2 */ ")", "", 1, 0, 0, 1 },
	{ /* 3 */ "(", "", 1, 0, 0, 1 },
	{ /* 4 */ "/", "", 1, 0, 0, 1 },
	{ /* 5 */ "*", "", 1, 0, 0, 1 },
	{ /* 6 */ "-", "", 1, 0, 0, 1 },
	{ /* 7 */ "+", "", 1, 0, 0, 1 },
	{ /* 8 */ "\\t ", "", 1, 0, 1, 1 },
	{ /* 9 */ "calc'", "", 0, 0, 0, 1 },
	{ /* 10 */ "int'", "", 0, 0, 0, 1 },
	{ /* 11 */ ")'", "", 0, 0, 0, 1 },
	{ /* 12 */ "('", "", 0, 0, 0, 1 },
	{ /* 13 */ "/'", "", 0, 0, 0, 1 },
	{ /* 14 */ "*'", "", 0, 0, 0, 1 },
	{ /* 15 */ "-'", "", 0, 0, 0, 1 },
	{ /* 16 */ "+'", "", 0, 0, 0, 1 },
	{ /* 17 */ "&whitespace*", "", 0, 1, 1, 1 },
	{ /* 18 */ "&whitespace+", "", 0, 1, 1, 1 },
	{ /* 19 */ "&whitespace", "", 0, 1, 1, 1 },
	{ /* 20 */ "expr", "", 0, 0, 0, 1 },
	{ /* 21 */ "calc", "", 0, 0, 0, 1 },
	{ /* 22 */ "int", "", 0, 1, 0, 1 }
};

/* Production information table */
UNICC_STATIC _prodinfo _productions[] =
{
	{ /* 0 */ "calc : expr ~&eof", "", 2, 21 },
	{ /* 1 */ "expr : expr +' expr", "", 3, 20 },
	{ /* 2 */ "expr : expr -' expr", "", 3, 20 },
	{ /* 3 */ "expr : expr *' expr", "", 3, 20 },
	{ /* 4 */ "expr : expr /' expr", "", 3, 20 },
	{ /* 5 */ "expr : (' expr )'", "", 3, 20 },
	{ /* 6 */ "expr : int'", "", 1, 20 },
	{ /* 7 */ "int : '0-9'", "", 1, 22 },
	{ /* 8 */ "int : int '0-9'", "", 2, 22 },
	{ /* 9 */ "&whitespace : '\\t '", "", 1, 19 },
	{ /* 10 */ "&whitespace+ : &whitespace+ &whitespace", "", 2, 18 },
	{ /* 11 */ "&whitespace+ : &whitespace", "", 1, 18 },
	{ /* 12 */ "&whitespace* : &whitespace+", "", 1, 17 },
	{ /* 13 */ "&whitespace* : ", "", 0, 17 },
	{ /* 14 */ "+' : '+' &whitespace*", "", 2, 16 },
	{ /* 15 */ "-' : '-' &whitespace*", "", 2, 15 },
	{ /* 16 */ "*' : '*' &whitespace*", "", 2, 14 },
	{ /* 17 */ "/' : '/' &whitespace*", "", 2, 13 },
	{ /* 18 */ "(' : '(' &whitespace*", "", 2, 12 },
	{ /* 19 */ ")' : ')' &whitespace*", "", 2, 11 },
	{ /* 20 */ "int' : int &whitespace*", "", 2, 10 },
	{ /* 21 */ "calc' : &whitespace* calc", "", 2, 9 }
};

UNICC_STATIC UNICC_SCHAR* _lexem( _pcb* pcb )
{
#if UNICC_WCHAR || !UNICC_UTF8
	pcb->lexem = pcb->buf;
#else
	size_t		size;

	size = wcstombs( (char*)NULL, pcb->buf, 0 );

	if( pcb->lexem )
		free( pcb->lexem );

	if( !( pcb->lexem = (UNICC_SCHAR*)malloc(
			( size + 1 ) * sizeof( UNICC_SCHAR ) ) ) )
	{
		UNICC_OUTOFMEM( pcb );
		return (UNICC_SCHAR*)NULL;
	}

	wcstombs( pcb->lexem, pcb->buf, size + 1 );
#endif

#if UNICC_DEBUG	> 2
	fprintf( stderr, "%s: lexem: pcb->lexem = >" UNICC_SCHAR_FORMAT "<\n",
						UNICC_PARSER, pcb->lexem );
#endif
	return pcb->lexem;
}

UNICC_STATIC _ast* _ast_free( _ast* node )
{
	if( !node )
		return (_ast*)NULL;

	_ast_free( node->child );
	_ast_free( node->next );

	if( node->token )
		free( node->token );

	free( node );
	return (_ast*)NULL;
}

UNICC_STATIC _ast* _ast_create( _pcb* pcb, char* emit,
													UNICC_SCHAR* token )
{
	_ast*	node;

	if( !( node = (_ast*)malloc( sizeof( _ast ) ) ) )
	{
		UNICC_OUTOFMEM( pcb );
		return node;
	}

	memset( node, 0, sizeof( _ast ) );

	node->emit = emit;

	if( token )
	{
		#if !UNICC_WCHAR
		if( !( node->token = strdup( token ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			free( node );
			return (_ast*)NULL;
		}
		#else
		if( !( node->token = wcsdup( token ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			free( node );
			return (_ast*)NULL;
		}
		#endif
	}

	return node;
}

UNICC_STATIC void _ast_print( FILE* stream, _ast* node )
{
	int 		i;
	static int 	rec;

	if( !node )
		return;

	if( !stream )
		stream = stderr;

	while( node )
	{
		for( i = 0; i < rec; i++ )
			fprintf( stream,  " " );

		fprintf( stream, "%s", node->emit );

		if( node->token && strcmp( node->emit, node->token ) != 0 )
			fprintf( stream, " (%s)", node->token );

		fprintf( stream, "\n" );

		rec++;
		_ast_print( stream, node->child );
		rec--;

		node = node->next;
	}
}

UNICC_STATIC int _get_act( _pcb* pcb )
{
	int i;

	for( i = 1; i < _act[ pcb->tos->state ][0] * 3; i += 3 )
	{
		if( _act[ pcb->tos->state ][i] == pcb->sym )
		{
			if( ( pcb->act = _act[ pcb->tos->state ][i+1] )
					== UNICC_ERROR )
				return 0; /* Force parse error! */

			pcb->idx = _act[ pcb->tos->state ][i+2];
			return 1;
		}
	}
	
	/* Default production */
	if( ( pcb->idx = _def_prod[ pcb->tos->state ] ) > -1 )
	{
		pcb->act = 1; /* Reduce */
		return 1;
	}

	return 0;
}

UNICC_STATIC int _get_go( _pcb* pcb )
{
	int i;

	for( i = 1; i < _go[ pcb->tos->state ][0] * 3; i += 3 )
	{
		if( _go[ pcb->tos->state ][i] == pcb->lhs )
		{
			pcb->act = _go[ pcb->tos->state ][ i + 1 ];
			pcb->idx = _go[ pcb->tos->state ][ i + 2 ];
			return 1;
		}
	}

	return 0;
}

UNICC_STATIC int _alloc_stack( _pcb* pcb )
{
	unsigned int	size;

	if( !pcb->stacksize )
	{
		if( !( pcb->tos = pcb->stack = (_tok*)malloc(
				UNICC_MALLOCSTEP * sizeof( _tok ) ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			return -1;
		}

		pcb->stacksize = UNICC_MALLOCSTEP;
	}
	else if( ( size = (unsigned int)( pcb->tos - pcb->stack ) )
				== pcb->stacksize )
	{
		_tok*	ptr;

		if( !( ptr = (_tok*)realloc( pcb->stack,
				( pcb->stacksize + UNICC_MALLOCSTEP )
					* sizeof( _tok ) ) ) )
		{
			UNICC_OUTOFMEM( pcb );

			if( pcb->stack )
				free( pcb->stack );

			return -1;
		}

		pcb->tos = pcb->stack = ptr;

		pcb->stacksize += UNICC_MALLOCSTEP;
		pcb->tos += size;
	}

	return 0;
}

#ifndef UNICC_GETINPUT

#if UNICC_UTF8
static int offsets_utf8[ 6 ] =
{
    0x00000000UL, 0x00003080UL, 0x000E2080UL,
    0x03C82080UL, 0xFA082080UL, 0x82082080UL
};

static int trailbyte_utf8[ 256 ] =
{
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
};

UNICC_STATIC UNICC_CHAR _utf8_getchar( int (*getfn)() )
{
	UNICC_CHAR	ch	= 0;
	int 		nb;
	int			c;
	
	if( !getfn )
		getfn = getchar;

	switch( ( nb = trailbyte_utf8[ ( c = (*getfn)() ) ] ) )
	{
        case 3:
			ch += c;
			ch <<= 6;
			c = (*getfn)();
        case 2:
			ch += c;
			ch <<= 6;
			c = (*getfn)();
        case 1:
			ch += c;
			ch <<= 6;
			c = (*getfn)();
        case 0:
			ch += c;
			break;
	}
	
	ch -= offsets_utf8[ nb ];
#if UNICC_DEBUG	> 3
	fprintf( stderr, "%s: getchar: %d\n", UNICC_PARSER, ch );
#endif
	return ch;
}
#define UNICC_GETINPUT		_utf8_getchar( getchar )

#else
#define UNICC_GETINPUT		getchar()
#endif

#endif

UNICC_STATIC UNICC_CHAR _get_input( _pcb* pcb, unsigned int offset )
{
#if UNICC_DEBUG	> 2
	fprintf( stderr, "%s: get input: pcb->buf + offset = %p pcb->bufend = %p\n",
				UNICC_PARSER, pcb->buf + offset, pcb->bufend );
#endif

	while( pcb->buf + offset >= pcb->bufend )
	{
#if UNICC_DEBUG	> 2
			fprintf( stderr, "%s: get input: requiring more input\n",
					UNICC_PARSER );
#endif
		if( !pcb->buf )
		{
			pcb->bufend = pcb->buf = (UNICC_CHAR*)malloc(
				( UNICC_MALLOCSTEP + 1 ) * sizeof( UNICC_CHAR ) );

			if( !pcb->buf )
			{
				UNICC_OUTOFMEM( pcb );
				return 0;
			}

			*pcb->buf = 0;
		}
		else if( *pcb->buf && !( ( pcb->bufend - pcb->buf ) %
					UNICC_MALLOCSTEP ) )
		{
			unsigned int 	size	= (unsigned int)( pcb->bufend - pcb->buf );
			UNICC_CHAR*		buf;

			if( !( buf = (UNICC_CHAR*)realloc( pcb->buf,
						( size + UNICC_MALLOCSTEP + 1 )
							* sizeof( UNICC_CHAR ) ) ) )
			{
				UNICC_OUTOFMEM( pcb );

				if( pcb->buf )
					free( pcb->buf );

				return 0;
			}

			pcb->buf = buf;
			pcb->bufend = pcb->buf + size;
		}

		if( pcb->is_eof || ( *( pcb->bufend ) = (UNICC_CHAR)UNICC_GETINPUT )
									== pcb->eof )
		{
#if UNICC_DEBUG	> 2
			fprintf( stderr, "%s: get input: can't get more input, "
						"end-of-file reached\n", UNICC_PARSER );
#endif
			pcb->is_eof = 1;
			return pcb->eof;
		}
#if UNICC_DEBUG	> 2
		fprintf( stderr, "%s: get input: read char >%c< %d\n",
					UNICC_PARSER, (char)*( pcb->bufend ), *( pcb->bufend ) );
#endif

#if UNICC_DEBUG	> 2
		fprintf( stderr, "%s: get input: reading character >%c< %d\n",
					UNICC_PARSER, (char)*( pcb->bufend ), *( pcb->bufend ) );
#endif

		*( ++pcb->bufend ) = 0;
	}

#if UNICC_DEBUG	> 2
	{
		UNICC_CHAR*		chptr;

		fprintf( stderr, "%s: get input: offset = %d\n",
					UNICC_PARSER, offset );
		fprintf( stderr, "%s: get input: buf = >" UNICC_CHAR_FORMAT "<\n",
					UNICC_PARSER, pcb->buf );
		fprintf( stderr, "%s: get input: returning %d\n",
					UNICC_PARSER, *( pcb->buf + offset ) );
	}
#endif

	return pcb->buf[ offset ];
}

UNICC_STATIC void _clear_input( _pcb* pcb )
{
	int		i;

	if( pcb->buf )
	{
		if( pcb->len )
		{
			/* Update counters for line and column */
			for( i = 0; i < pcb->len; i++ )
			{
				if( (char)pcb->buf[i] == '\n' )
				{
					pcb->line++;
					pcb->column = 1;
				}
				else
					pcb->column++;
			}

#if UNICC_DEBUG > 2
	fprintf( stderr, "%s: clear input: "
		"Clearing %d characters (%d bytes)\n",
			UNICC_PARSER, pcb->len, pcb->len * sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: buf = >" UNICC_CHAR_FORMAT "<\n",
			UNICC_PARSER, pcb->buf, sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: pcb->bufend >" UNICC_CHAR_FORMAT "<\n",
			UNICC_PARSER, pcb->bufend );
#endif

			memmove( pcb->buf, pcb->buf + pcb->len,
						( ( pcb->bufend - ( pcb->buf + pcb->len ) ) + 1 + 1 )
							* sizeof( UNICC_CHAR ) );
			pcb->bufend = pcb->buf + ( pcb->bufend - ( pcb->buf + pcb->len ) );

#if UNICC_DEBUG	> 2
	fprintf( stderr, "%s: clear input: now buf = >" UNICC_CHAR_FORMAT "<\n",
				UNICC_PARSER, pcb->buf, sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: now bufend = >" UNICC_CHAR_FORMAT "<\n",
				UNICC_PARSER, pcb->bufend, sizeof( UNICC_CHAR ) );
#endif
		}
		else
		{
			pcb->bufend = pcb->buf;
			*( pcb->buf ) = 0;
		}
	}
	
	pcb->len = 0;
	pcb->sym = -1;
#if UNICC_DEBUG	> 2
	fprintf( stderr, "%s: clear input: symbol cleared\n", UNICC_PARSER );
#endif
}

#if 7
UNICC_STATIC void _lex( _pcb* pcb )
{
	int 			dfa_st	= 0;
	unsigned int	len		= 0;
	int				chr;
	UNICC_CHAR		next;
#if !0
	int				mach	= _dfa_select[ pcb->tos->state ];
#else
	int				mach	= 0;
#endif

	next = _get_input( pcb, len );
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif
	
	if( next == pcb->eof )
	{
		pcb->sym = 0;
		return;
	}

	do
	{
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif

		chr = _dfa_idx[ mach ][ dfa_st ];
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: chr = %d\n", UNICC_PARSER, chr );
#endif

		dfa_st = -1;
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: FIRST next = %d _dfa_chars[ chr ] = %d, "
			"_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
				_dfa_chars[ chr ], _dfa_chars[ chr + 1 ] );
#endif
		while( _dfa_chars[ chr ] > -1 )
		{
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: next = %d _dfa_chars[ chr ] = %d, "
		"_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
			_dfa_chars[ chr ], _dfa_chars[ chr + 1 ] );
#endif
			if( next >= _dfa_chars[ chr ] &&
				next <= _dfa_chars[ chr+1 ] )
			{
				dfa_st = *( _dfa_trans + ( chr / 2 ) );
#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: dfa_st = %d\n", UNICC_PARSER, dfa_st );
#endif
				if( _dfa_accept[ mach ][ dfa_st ] > 0 )
				{
					pcb->len = len + 1;
					pcb->sym = _dfa_accept[ mach ][ dfa_st ] - 1;

#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: new accepting symbol pcb->sym = %d greedy = %d\n",
			UNICC_PARSER, pcb->sym, _symbols[ pcb->sym ].greedy );
#endif
					if( pcb->sym == 0 )
					{
						dfa_st = -1; /* test! */
						break;
					}

					/* Stop if matched symbol should be parsed nongreedy */
					if( !_symbols[ pcb->sym ].greedy )
					{
						dfa_st = -1;
						break;
					}
				}

				next = _get_input( pcb, ++len );
				break;
			}

			chr += 2;
		}
	}
	while( dfa_st > -1 && next != pcb->eof );
	
	if( pcb->sym > -1 )
	{
#if UNICC_SEMANTIC_TERM_SEL
		/*
			Execute scanner actions, if existing, but with
			UNICC_ON_SHIFT = 0, so that no memory allocation 
			should be performed. This actions should only be
			handled if there are semantic-code dependent
			terminal symbol selections.

			tos is incremented here, if the semantic code
			stores data for the symbol. It won't get lost
			in case of a shift.
		*/
		_alloc_stack( pcb );
		pcb->tos++;

		next = pcb->buf[ pcb->len ];
		pcb->buf[ pcb->len ] = '\0';
		
#define UNICC_ON_SHIFT 	0
		switch( pcb->sym )
		{


			default:
				break;
		}
#undef UNICC_ON_SHIFT

		pcb->buf[ pcb->len ] = next;

		pcb->tos--;
#endif /* UNICC_SEMANTIC_TERM_SEL */
	}

#if UNICC_DEBUG	> 1
fprintf( stderr, "%s: lex: function exits, pcb->sym = %d, pcb->len = %d\n",
			UNICC_PARSER, pcb->sym, pcb->len );
#endif
}
#endif

UNICC_STATIC int _get_sym( _pcb* pcb )
{
	pcb->sym = -1;
	pcb->len = 0;

#if 0
	do
	{
#endif
#if !0

#if UNICC_DEBUG > 2
		fprintf( stderr, "%s: get sym: state = %d dfa_select = %d\n",
					UNICC_PARSER, pcb->tos->state,
						_dfa_select[ pcb->tos->state ] );
#endif

		if( _dfa_select[ pcb->tos->state ] > -1 )
			_lex( pcb );
		/* 
		 * If there is no DFA state machine,
		 * try to identify the end-of-file symbol.
		 * If this also fails, a parse error will
		 * raise.
		 */
		else if( _get_input( pcb, 0 ) == pcb->eof )
			pcb->sym = 0;
#else
		_lex( pcb );
#endif /* !0 */

#if 0

		if( pcb->sym > -1 && _symbols[ pcb->sym ].whitespace )
		{
			UNICC_CLEARIN( pcb );
			continue;
		}
		
		break;
	}
	while( 1 );
#endif /* 0 */

	return ( pcb->sym > -1 ) ? 1 : 0;
}

#if UNICC_STACKDEBUG
UNICC_STATIC void _dbg_stack( FILE* out,
	_tok* stack, _tok* tos )
{
	fprintf( out, "%s: Stack Dump: ", UNICC_PARSER );

	for( ; stack <= tos; stack++ )
	{
		fprintf( out, "%d%s%s%s ", stack->state,
			stack->symbol ? " (" : "",
			stack->symbol ? stack->symbol->name : "",
			stack->symbol ? ")" : "" );
	}
	
	fprintf( out, "\n" );
}
#endif /* UNICC_STACKDEBUG */

UNICC_STATIC int _handle_error( _pcb* pcb, FILE* _dbg )
{
#if UNICC_DEBUG
	int					i;
#endif

	if( !pcb->error_delay )
	{
#if UNICC_DEBUG
		fprintf( _dbg, "%s: !!!PARSE ERROR!!!\n"
				"%s: error recovery: current token %d (%s)\n",
					UNICC_PARSER, UNICC_PARSER, pcb->sym,
						( ( pcb->sym >= 0 ) ?
							_symbols[ pcb->sym ].name :
								"(null)" ) );

		fprintf( _dbg,
				"%s: error recovery: expecting ", UNICC_PARSER );
				
		for( i = 1; i < _act[ pcb->tos->state ][0] * 3; i += 3 )
		{
			fprintf( _dbg, "%d (%s)%s",
				_act[ pcb->tos->state ][i],
				_symbols[ _act[ pcb->tos->state ][i] ].name,
				( i == _act[ pcb->tos->state ][0] * 3 - 3 ) ?
						"\n" : ", " );
		}
		
		fprintf( _dbg, "\n%s: error recovery: error_delay is %d, %s\n",
					UNICC_PARSER, pcb->error_delay,
					( pcb->error_delay ? "error recovery runs silently" :
						"error is reported before its recover!" ) );
#endif
	}

#if -1 < 0
	/* No error token defined? Then exit here... */

#if UNICC_DEBUG
	fprintf( _dbg,
		"%s: error recovery: No error resync token used by grammar, "
			"exiting parser.\n", UNICC_PARSER );
#endif

	UNICC_PARSE_ERROR( pcb );
	pcb->error_count++;

	return 1;
#else
	/*
	_pcb 		org_pcb;
	*/

#if UNICC_DEBUG
	fprintf( _dbg, "%s: error recovery: "
		"trying to recover...\n", UNICC_PARSER );
#if UNICC_STACKDEBUG
	_dbg_stack( _dbg, pcb->stack, pcb->tos );
#endif
#endif

	#if 0
	/* Create a copy of original parser control block (maybe later...) */
	memcpy( &org_pcb, pcb, sizeof( _pcb ) );
	org_pcb.buf = (char*)malloc( ( strlen( pcb->buf ) / UNICC_MALLOCSTEP +
					( !( strlen( pcb->buf ) % UNICC_MALLOCSTEP ) ? 1 : 0 ) )
							* UNICC_MALLOCSTEP );
	strcpy( org_pcb.buf, pcb->buf );
	#endif

	/* Remember previous symbol, or discard it */
	if( pcb->error_delay != UNICC_ERROR_DELAY )
		pcb->old_sym = pcb->sym;
	else
	{
		pcb->old_sym = -1;
		pcb->len = 1;
		UNICC_CLEARIN( pcb );
	}

	/* Try to shift on error resync */
	pcb->sym = -1;

	while( pcb->tos >= pcb->stack )
	{
#if UNICC_DEBUG
		fprintf( _dbg, "%s: error recovery: in state %d, trying "
				"to shift error resync token...\n",
					UNICC_PARSER, pcb->tos->state );
#if UNICC_STACKDEBUG
		_dbg_stack( _dbg, pcb->stack, pcb->tos );
#endif
#endif
		if( _get_act( pcb ) )
		{
			/* Shift */
			if( pcb->act & UNICC_SHIFT )
			{
#if UNICC_DEBUG
				fprintf( _dbg, "%s: error recovery: "
							"error resync shifted\n", UNICC_PARSER );
#endif
				break;
			}
		}
		
#if UNICC_DEBUG
		fprintf( _dbg, "%s: error recovery: failed, "
					"discarding token '%s'\n", UNICC_PARSER,
						pcb->tos->symbol ?
							pcb->tos->symbol->name : "NULL" );
#endif

		/* Discard one token from stack */
		/* TODO: Discarded token memory (semantic action) */
		pcb->tos--;
	}

	if( pcb->tos <= pcb->stack )
	{
#if UNICC_DEBUG
	fprintf( _dbg, "%s: error recovery: "
				"Can't recover this issue, stack is empty.\n",
					UNICC_PARSER );	
#endif
		UNICC_PARSE_ERROR( pcb );
		pcb->error_count++;

		return 1;
	}
	
#if UNICC_DEBUG
	fprintf( _dbg, "%s: error recovery: "
				"trying to continue with modified parser state\n",
					UNICC_PARSER );	
#endif

	pcb->error_delay = UNICC_ERROR_DELAY + 1;

	return 0;

#endif /* -1 >= 0 */
}

int _parse( _pcb* pcb )
{
	int			ret;
	int					i;

	_ast*		node;
	_ast*		lnode;

#if UNICC_DEBUG
	_vtype*		vptr;
	FILE* 				_dbg;

	_dbg = stderr;
#endif

	/* If there is no Parser Control Block given, allocate your own one! */
	if( !pcb )
	{
		if( !( pcb = (_pcb*)malloc( sizeof( _pcb ) ) ) )
		{
			/* Can't allocate memory */
			UNICC_OUTOFMEM( pcb );
			return (int)0;
		}

		memset( pcb, 0, sizeof( _pcb ) );
		pcb->is_internal = 1;
	}
	else
		pcb->is_internal = 0;

	/* Initialize Parser Control Block */
	pcb->stacksize = 0;
	if( _alloc_stack( pcb ) < 0 )
		return (int)0;

	memset( pcb->tos, 0, sizeof( _tok ) );

	pcb->act = UNICC_SHIFT;
	pcb->sym = -1;
	pcb->old_sym = -1;
	pcb->line = 1;
	pcb->column = 1;

	memset( &pcb->test, 0, sizeof( _vtype ) );

	/* Begin of main parser loop */
	while( 1 )
	{
		/* Reduce */
		while( pcb->act & UNICC_REDUCE )
		{
#if UNICC_DEBUG
			fprintf( _dbg, "%s: << "
					"reducing by production %d (%s)\n",
						UNICC_PARSER, pcb->idx,
							_productions[ pcb->idx ].definition );
#endif
			/* Set default left-hand side */
			pcb->lhs = _productions[ pcb->idx ].lhs;

			/* Run reduction code */
			memset( &( pcb->ret ), 0, sizeof( _vtype ) );

			switch( pcb->idx )
			{
				case 0:
				{
					#line 11 "expr.par"
 printf( "= %d\n", ( ( pcb->tos - 1 )->value ) ) 
					;
				}				break;
					case 1:
				{
					#line 14 "expr.par"
 pcb->ret = ( ( pcb->tos - 2 )->value ) + ( ( pcb->tos - 0 )->value ) 
					;
				}				break;
					case 2:
				{
					#line 15 "expr.par"
 pcb->ret = ( ( pcb->tos - 2 )->value ) - ( ( pcb->tos - 0 )->value ) 
					;
				}				break;
					case 3:
				{
					#line 16 "expr.par"
 pcb->ret = ( ( pcb->tos - 2 )->value ) * ( ( pcb->tos - 0 )->value ) 
					;
				}				break;
					case 4:
				{
					#line 17 "expr.par"
 pcb->ret = ( ( pcb->tos - 2 )->value ) / ( ( pcb->tos - 0 )->value ) 
					;
				}				break;
					case 5:
				{
					#line 18 "expr.par"
 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 6:
				{
					 pcb->ret = ( ( pcb->tos - 0 )->value ) 
					;
				}				break;
					case 7:
				{
					#line 22 "expr.par"
 pcb->ret = ( ( pcb->tos - 0 )->value ) - '0' 
					;
				}				break;
					case 8:
				{
					#line 23 "expr.par"
 pcb->ret = ( ( pcb->tos - 1 )->value ) * 10 + ( ( pcb->tos - 0 )->value ) - '0' 
					;
				}				break;
					case 14:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 15:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 16:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 17:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 18:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 19:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 20:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
					case 21:
				{
					 pcb->ret = ( ( pcb->tos - 1 )->value ) 
					;
				}				break;
	
			}

			/* Drop right-hand side */
			/* TODO: Destructor callbacks? */
			for( i = 0, node = (_ast*)NULL;
					i < _productions[ pcb->idx ].length;
						i++ )
			{
				if( pcb->tos->node )
				{
					if( node )
					{
						while( node->prev )
							node = node->prev;

						node->prev = pcb->tos->node;
						pcb->tos->node->next = node;
					}

					node = pcb->tos->node;
					pcb->tos->node = (_ast*)NULL;
				}

				pcb->tos--;
			}

			/* This could be done if no AST construction would be done: */
			/* pcb->tos -= _productions[ pcb->idx ].length; */

			if( node )
			{
				if( lnode = pcb->tos->node )
				{
					while( lnode->next )
						lnode = lnode->next;

					lnode->next = node;
					node->prev = lnode;
				}
				else
					pcb->tos->node = node;
			}

			if( *_productions[ pcb->idx ].emit )
			{
				if( ( node = _ast_create( pcb,
								_productions[ pcb->idx ].emit,
									(UNICC_SCHAR*)NULL ) ) )
				{
					node->child = pcb->tos->node;
					pcb->tos->node = node;
				}
			}

			/* Enforced error in semantic actions? */
			if( pcb->act == UNICC_ERROR )
				break;

			/* Goal symbol reduced, and stack is empty? */
			if( pcb->lhs == 9 && pcb->tos == pcb->stack )
			{
				memcpy( &( pcb->tos->value ), &( pcb->ret ),
							sizeof( _vtype ) );
				pcb->ast = pcb->tos->node;

				UNICC_CLEARIN( pcb );

				pcb->act = UNICC_SUCCESS;

				#if UNICC_DEBUG
				fprintf( stderr, "%s: goal symbol reduced, exiting parser\n",
						UNICC_PARSER );
				#endif
				break;
			}

			#if UNICC_DEBUG
			fprintf( _dbg, "%s: after reduction, "
						"shifting nonterminal %d (%s)\n",
							UNICC_PARSER, pcb->lhs,
								_symbols[ pcb->lhs ].name );
			#endif

			_get_go( pcb );

			pcb->tos++;
			pcb->tos->node = (_ast*)NULL;

			memcpy( &( pcb->tos->value ), &( pcb->ret ),
						sizeof( _vtype ) );
			pcb->tos->symbol = &( _symbols[ pcb->lhs ] );
			pcb->tos->state = ( pcb->act & UNICC_REDUCE ) ? -1 : pcb->idx;
			pcb->tos->line = pcb->line;
			pcb->tos->column = pcb->column;
		}

		if( pcb->act == UNICC_SUCCESS || pcb->act == UNICC_ERROR )
			break;

		/* If in error recovery, replace old-symbol */
		if( pcb->error_delay == UNICC_ERROR_DELAY
				&& ( pcb->sym = pcb->old_sym ) < 0 )
		{
			/* If symbol is invalid, try to find new token */
			#if UNICC_DEBUG
			fprintf( _dbg, "%s: error recovery: "
				"old token invalid, requesting new token\n",
						UNICC_PARSER );
			#endif

			while( !_get_sym( pcb ) )
			{
				/* Skip one character */
				pcb->len = 1;

				UNICC_CLEARIN( pcb );
			}

			#if UNICC_DEBUG
			fprintf( _dbg, "%s: error recovery: "
				"new token %d (%s)\n", UNICC_PARSER, pcb->sym,
					_symbols[ pcb->sym ].name );
			#endif
		}
		else
		{
			_get_sym( pcb );
		}

#if UNICC_DEBUG
		fprintf( _dbg, "%s: current token %d (%s)\n",
					UNICC_PARSER, pcb->sym,
						( pcb->sym < 0 ) ? "(null)" :
							_symbols[ pcb->sym ].name );
#endif

		/* Get action table entry */
		if( !_get_act( pcb ) )
		{
			/* Error state, try to recover */
			if( _handle_error( pcb,
#if UNICC_DEBUG
					_dbg
#else
					(FILE*)NULL
#endif
					) )
				break;
		}

#if UNICC_DEBUG
		fprintf( _dbg,
			"%s: sym = %d (%s) [len = %d] tos->state = %d act = %s idx = %d\n",
				UNICC_PARSER, pcb->sym,
					( ( pcb->sym >= 0 ) ?
						_symbols[ pcb->sym ].name :
							"(invalid symbol id)" ),
					pcb->len, pcb->tos->state,
						( ( pcb->act == UNICC_SHIFT & UNICC_REDUCE ) ?
								"shift/reduce" :
							( pcb->act & UNICC_SHIFT ) ?
									"shift" : "reduce" ), pcb->idx );
#if UNICC_STACKDEBUG
		_dbg_stack( _dbg, pcb->stack, pcb->tos );
#endif
#endif

		/* Shift */
		if( pcb->act & UNICC_SHIFT )
		{
			pcb->next = pcb->buf[ pcb->len ];
			pcb->buf[ pcb->len ] = '\0';

#if UNICC_DEBUG
			fprintf( _dbg, "%s: >> shifting terminal %d (%s)\n",
			UNICC_PARSER, pcb->sym, _symbols[ pcb->sym ].name );
#endif

			if( _alloc_stack( pcb ) < 0 )
				return (int)0;

			pcb->tos++;
			pcb->tos->node = (_ast*)NULL;

			/*
				Execute scanner actions, if existing.
				Here, UNICC_ON_SHIFT is set to 1, so that shifting-
				related operations will be performed.
			*/
#define UNICC_ON_SHIFT	1
			switch( pcb->sym )
			{


				default:
					( ( pcb->tos - 0 )->value ) = _get_input( pcb, 0 );
					break;
			}
#undef UNICC_ON_SHIFT

			pcb->tos->state = ( pcb->act & UNICC_REDUCE ) ? -1 : pcb->idx;
			pcb->tos->symbol = &( _symbols[ pcb->sym ] );
			pcb->tos->line = pcb->line;
			pcb->tos->column = pcb->column;

			if( *pcb->tos->symbol->emit )
				pcb->tos->node = _ast_create( pcb,
									pcb->tos->symbol->emit,
										_lexem( pcb ) );
			else
				pcb->tos->node = (_ast*)NULL;

			pcb->buf[ pcb->len ] = pcb->next;

			/* Perform the shift on input */
			if( pcb->sym != 0 && pcb->sym != -1 )
			{
				UNICC_CLEARIN( pcb );
				pcb->old_sym = -1;
			}

			if( pcb->error_delay )
				pcb->error_delay--;
		}
	}

	#if UNICC_DEBUG
	fprintf( _dbg, "%s: parse completed with %d errors\n",
		UNICC_PARSER, pcb->error_count );
	#endif

	/* Save return value */
	ret = ( ( pcb->tos - 0 )->value );

	/* Clean up parser control block */
	if( pcb->buf )
		free( pcb->buf );
	if( pcb->stack )
		free( pcb->stack );
#if UNICC_UTF8
	if( pcb->lexem )
		free( pcb->lexem );
#endif

	/* Clean memory of self-allocated parser control block */
	if( pcb->is_internal )
		free( pcb );

	return ret;
}



/* Create Main? */
#if 0 == 0
	#ifndef UNICC_MAIN
	#define UNICC_MAIN 	1
	#endif
#else
	#ifndef UNICC_MAIN
	#define UNICC_MAIN 	0
	#endif
#endif

#if UNICC_MAIN

int main( int argc, char** argv )
{
#define UNICCMAIN_SILENT		1
#define UNICCMAIN_ENDLESS		2
#define UNICCMAIN_LINEMODE		4
#define UNICCMAIN_SYNTAXTREE	8
#define UNICCMAIN_AUGSYNTAXTREE	16

	char*			opt;
	int				flags	= 0;
	int				i;
	_pcb	pcb;

#ifdef LC_ALL
	setlocale( LC_ALL, "" );
#endif

	/* Get command-line options */
	for( i = 1; i < argc; i++ )
	{
		if( *(argv[i]) == '-' )
		{
			opt = argv[i] + 1;

			/* Long option coming? */
			if( *opt == '-' )
			{
				opt++;

				if( !strcmp( opt, "silent" ) )
					flags |= UNICCMAIN_SILENT;
				else if( !strcmp( opt, "endless" ) )
					flags |= UNICCMAIN_ENDLESS;
				else if( !strcmp( opt, "line-mode" ) )
					flags |= UNICCMAIN_LINEMODE;
				else
				{
					fprintf( stderr, "Unknown option '--%s'\n", argv[i] );
					return 1;
				}
			}

			for( ; *opt; opt++ )
			{
				if( *opt == 's' )
					flags |= UNICCMAIN_SILENT;
				else if( *opt == 'e' )
					flags |= UNICCMAIN_ENDLESS;
				else if( *opt == 'l' )
					flags |= UNICCMAIN_LINEMODE;
				else
				{
					fprintf( stderr, "Unknown option '-%c'\n", *opt );
					return 1;
				}
			}
		}
	}

	/* Parser invocation loop */
	do
	{
		if( !( flags & UNICCMAIN_SILENT ) )
			printf( "\nok\n" );

		/* Invoke parser */
		memset( &pcb, 0, sizeof( _pcb ) );

		if( flags & UNICCMAIN_LINEMODE )
			pcb.eof = '\n';
		else
			pcb.eof = EOF;

		_parse( &pcb );

		/* Print AST */
		if( pcb.ast )
		{
			_ast_print( stderr, pcb.ast );
			_ast_free( pcb.ast );
		}
	}
	while( flags & UNICCMAIN_ENDLESS );

	return 0;
}
#endif


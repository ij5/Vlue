Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CATCH
    CLASS
    COLON
    COMMA
    DEBUG
    DOT
    ELSE
    EQUAL
    FOR
    FUNCTION
    GLOBAL
    IDENTIFIER
    IF
    IN
    LB
    LIST
    LMB
    LSB
    PYTHON
    RB
    REPEAT
    RMB
    RSB
    SEMI
    STRING
    TRY
    USE
    VAR
    WHILE

Grammar

Rule 0     S' -> root
Rule 1     root -> statement
Rule 2     statement -> expression
Rule 3     expression -> calculate
Rule 4     calculate -> calculate baseoperator INT
Rule 5     calculate -> calculate baseoperator FLOAT
Rule 6     calculate -> INT
Rule 7     calculate -> FLOAT
Rule 8     baseoperator -> PLUS
Rule 9     baseoperator -> MINUS
Rule 10    baseoperator -> MUL
Rule 11    baseoperator -> DIV
Rule 12    empty -> <empty>

Terminals, with rules where they appear

CATCH                : 
CLASS                : 
COLON                : 
COMMA                : 
DEBUG                : 
DIV                  : 11
DOT                  : 
ELSE                 : 
EQUAL                : 
FLOAT                : 5 7
FOR                  : 
FUNCTION             : 
GLOBAL               : 
IDENTIFIER           : 
IF                   : 
IN                   : 
INT                  : 4 6
LB                   : 
LIST                 : 
LMB                  : 
LSB                  : 
MINUS                : 9
MUL                  : 10
PLUS                 : 8
PYTHON               : 
RB                   : 
REPEAT               : 
RMB                  : 
RSB                  : 
SEMI                 : 
STRING               : 
TRY                  : 
USE                  : 
VAR                  : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

baseoperator         : 4 5
calculate            : 3 4 5
empty                : 
expression           : 2
root                 : 0
statement            : 1

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . statement
    (2) statement -> . expression
    (3) expression -> . calculate
    (4) calculate -> . calculate baseoperator INT
    (5) calculate -> . calculate baseoperator FLOAT
    (6) calculate -> . INT
    (7) calculate -> . FLOAT

    INT             shift and go to state 5
    FLOAT           shift and go to state 6

    root                           shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 3
    calculate                      shift and go to state 4

state 1

    (0) S' -> root .



state 2

    (1) root -> statement .

    $end            reduce using rule 1 (root -> statement .)


state 3

    (2) statement -> expression .

    $end            reduce using rule 2 (statement -> expression .)


state 4

    (3) expression -> calculate .
    (4) calculate -> calculate . baseoperator INT
    (5) calculate -> calculate . baseoperator FLOAT
    (8) baseoperator -> . PLUS
    (9) baseoperator -> . MINUS
    (10) baseoperator -> . MUL
    (11) baseoperator -> . DIV

    $end            reduce using rule 3 (expression -> calculate .)
    PLUS            shift and go to state 8
    MINUS           shift and go to state 9
    MUL             shift and go to state 10
    DIV             shift and go to state 11

    baseoperator                   shift and go to state 7

state 5

    (6) calculate -> INT .

    PLUS            reduce using rule 6 (calculate -> INT .)
    MINUS           reduce using rule 6 (calculate -> INT .)
    MUL             reduce using rule 6 (calculate -> INT .)
    DIV             reduce using rule 6 (calculate -> INT .)
    $end            reduce using rule 6 (calculate -> INT .)


state 6

    (7) calculate -> FLOAT .

    PLUS            reduce using rule 7 (calculate -> FLOAT .)
    MINUS           reduce using rule 7 (calculate -> FLOAT .)
    MUL             reduce using rule 7 (calculate -> FLOAT .)
    DIV             reduce using rule 7 (calculate -> FLOAT .)
    $end            reduce using rule 7 (calculate -> FLOAT .)


state 7

    (4) calculate -> calculate baseoperator . INT
    (5) calculate -> calculate baseoperator . FLOAT

    INT             shift and go to state 12
    FLOAT           shift and go to state 13


state 8

    (8) baseoperator -> PLUS .

    INT             reduce using rule 8 (baseoperator -> PLUS .)
    FLOAT           reduce using rule 8 (baseoperator -> PLUS .)


state 9

    (9) baseoperator -> MINUS .

    INT             reduce using rule 9 (baseoperator -> MINUS .)
    FLOAT           reduce using rule 9 (baseoperator -> MINUS .)


state 10

    (10) baseoperator -> MUL .

    INT             reduce using rule 10 (baseoperator -> MUL .)
    FLOAT           reduce using rule 10 (baseoperator -> MUL .)


state 11

    (11) baseoperator -> DIV .

    INT             reduce using rule 11 (baseoperator -> DIV .)
    FLOAT           reduce using rule 11 (baseoperator -> DIV .)


state 12

    (4) calculate -> calculate baseoperator INT .

    PLUS            reduce using rule 4 (calculate -> calculate baseoperator INT .)
    MINUS           reduce using rule 4 (calculate -> calculate baseoperator INT .)
    MUL             reduce using rule 4 (calculate -> calculate baseoperator INT .)
    DIV             reduce using rule 4 (calculate -> calculate baseoperator INT .)
    $end            reduce using rule 4 (calculate -> calculate baseoperator INT .)


state 13

    (5) calculate -> calculate baseoperator FLOAT .

    PLUS            reduce using rule 5 (calculate -> calculate baseoperator FLOAT .)
    MINUS           reduce using rule 5 (calculate -> calculate baseoperator FLOAT .)
    MUL             reduce using rule 5 (calculate -> calculate baseoperator FLOAT .)
    DIV             reduce using rule 5 (calculate -> calculate baseoperator FLOAT .)
    $end            reduce using rule 5 (calculate -> calculate baseoperator FLOAT .)

